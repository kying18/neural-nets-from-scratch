"""
Generate training videos for decision boundaries.

This file was generated by Cursor.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, FFMpegWriter, PillowWriter
from matplotlib.colors import LinearSegmentedColormap
import warnings
warnings.filterwarnings('ignore')


# Playground.tensorflow.org color scheme
PLAYGROUND_COLORS = {
    'class_0': '#D87373',
    'class_1': '#3E6589',
    'background': '#F7F7F7',
    'grid': '#E0E0E0',
    'text': '#2C3E50',
    'accent': '#FFD93D',
}


def create_visualization_colormap():
    # red to white to blue
    colors = ['#D87373', '#FFFFFF', '#3E6589']
    n_bins = 256
    cmap = LinearSegmentedColormap.from_list('visualization', colors, N=n_bins)
    return cmap


def animate_decision_boundary_training(model, X, y, recorder, resolution=200, 
                                      fps=10, title="Decision Boundary Evolution",
                                      save_path="decision_boundary_training.mp4"):
    """
    Create animated video of decision boundary evolving during training.
    
    Args:
        model: Sequential model
        X: Training data (N, 2) - uses first 2 dimensions
        y: Labels (N,)
        recorder: TrainingRecorder with training history
        resolution: Grid resolution
        fps: Frames per second
        title: Video title
        save_path: Path to save video
    """
    # Create mesh
    x_min, x_max = X[:, 0].min() - 0.5, X[:, 0].max() + 0.5
    y_min, y_max = X[:, 1].min() - 0.5, X[:, 1].max() + 0.5
    
    xx, yy = np.meshgrid(np.linspace(x_min, x_max, resolution),
                        np.linspace(y_min, y_max, resolution))
    
    mesh_points = np.c_[xx.ravel(), yy.ravel()]
    
    # Check if model expects 3D input
    if hasattr(model.layers[0], 'W') and model.layers[0].W.shape[0] == 3:
        r = np.sqrt(mesh_points[:, 0]**2 + mesh_points[:, 1]**2).reshape(-1, 1)
        mesh_input = np.hstack([mesh_points, r])
    else:
        mesh_input = mesh_points
    
    # Setup figure with playground style
    fig, ax = plt.subplots(figsize=(12, 10))
    fig.patch.set_facecolor(PLAYGROUND_COLORS['background'])
    ax.set_facecolor('white')
    
    # Create colormap
    cmap = create_visualization_colormap()
    
    # Initial plot
    recorder.restore_model_state(model, recorder.get_all_epochs()[0])
    Z = model.forward(mesh_input)
    if Z.shape[1] == 1:
        Z = Z.reshape(xx.shape)
    else:
        Z = Z[:, 0].reshape(xx.shape)
    
    contour = ax.contourf(xx, yy, Z, levels=50, cmap=cmap, alpha=0.8, vmin=0, vmax=1)
    ax.contour(xx, yy, Z, levels=[0.5], colors='black', linewidths=2.5, linestyles='-', alpha=0.8)
    
    # Plot data points with playground colors
    scatter = ax.scatter(X[:, 0], X[:, 1], 
                        c=[PLAYGROUND_COLORS['class_0'] if label == 0 else PLAYGROUND_COLORS['class_1'] 
                           for label in y.flatten()],
                        edgecolors='white', linewidths=2, s=80, alpha=0.9, zorder=10)
    
    ax.set_xlabel('Feature 1', fontsize=14, fontweight='bold', color=PLAYGROUND_COLORS['text'])
    ax.set_ylabel('Feature 2', fontsize=14, fontweight='bold', color=PLAYGROUND_COLORS['text'])
    ax.set_title(title, fontsize=18, fontweight='bold', color=PLAYGROUND_COLORS['text'], pad=20)
    ax.grid(True, color=PLAYGROUND_COLORS['grid'], alpha=0.3, linestyle='--', linewidth=0.5)
    ax.set_xlim(x_min, x_max)
    ax.set_ylim(y_min, y_max)
    
    # Add epoch text
    epoch_text = ax.text(0.02, 0.98, '', transform=ax.transAxes, 
                        fontsize=16, fontweight='bold', color=PLAYGROUND_COLORS['text'],
                        verticalalignment='top', bbox=dict(boxstyle='round', 
                        facecolor='white', alpha=0.8, edgecolor=PLAYGROUND_COLORS['grid']))
    
    # Add loss text
    loss_text = ax.text(0.02, 0.90, '', transform=ax.transAxes,
                       fontsize=14, color=PLAYGROUND_COLORS['text'],
                       verticalalignment='top', bbox=dict(boxstyle='round',
                       facecolor='white', alpha=0.8, edgecolor=PLAYGROUND_COLORS['grid']))
    
    plt.tight_layout()
    
    # Animation function
    def animate(frame):
        ax.clear()
        ax.set_facecolor('white')
        
        epoch = recorder.get_all_epochs()[frame]
        state = recorder.get_state_at_epoch(epoch)
        
        # Restore model state
        recorder.restore_model_state(model, epoch)
        
        # Recompute decision boundary
        Z = model.forward(mesh_input)
        if Z.shape[1] == 1:
            Z = Z.reshape(xx.shape)
        else:
            Z = Z[:, 0].reshape(xx.shape)
        
        # Plot
        contour = ax.contourf(xx, yy, Z, levels=50, cmap=cmap, alpha=0.8, vmin=0, vmax=1)
        ax.contour(xx, yy, Z, levels=[0.5], colors='gray', linewidths=2.5, linestyles=':', alpha=0.6)
        
        scatter = ax.scatter(X[:, 0], X[:, 1],
                           c=[PLAYGROUND_COLORS['class_0'] if label == 0 else PLAYGROUND_COLORS['class_1']
                              for label in y.flatten()],
                           edgecolors='white', linewidths=2, s=80, alpha=0.9, zorder=10)
        
        ax.set_xlabel('Feature 1', fontsize=14, fontweight='bold', color=PLAYGROUND_COLORS['text'])
        ax.set_ylabel('Feature 2', fontsize=14, fontweight='bold', color=PLAYGROUND_COLORS['text'])
        ax.set_title(title, fontsize=18, fontweight='bold', color=PLAYGROUND_COLORS['text'], pad=20)
        ax.grid(True, color=PLAYGROUND_COLORS['grid'], alpha=0.3, linestyle='--', linewidth=0.5)
        ax.set_xlim(x_min, x_max)
        ax.set_ylim(y_min, y_max)
        
        # Update text
        epoch_text = ax.text(0.02, 0.98, f'Epoch: {epoch}', transform=ax.transAxes,
                            fontsize=16, fontweight='bold', color=PLAYGROUND_COLORS['text'],
                            verticalalignment='top', bbox=dict(boxstyle='round',
                            facecolor='white', alpha=0.9, edgecolor=PLAYGROUND_COLORS['grid']))
        
        loss_val = state.get('loss', 0)
        acc_val = state.get('accuracy', 0)
        loss_text = ax.text(0.02, 0.90, f'Loss: {loss_val:.4f}\nAccuracy: {acc_val:.2%}',
                           transform=ax.transAxes, fontsize=14, color=PLAYGROUND_COLORS['text'],
                           verticalalignment='top', bbox=dict(boxstyle='round',
                           facecolor='white', alpha=0.9, edgecolor=PLAYGROUND_COLORS['grid']))
        
        return contour, scatter, epoch_text, loss_text
    
    # Create animation
    n_frames = len(recorder.history)
    anim = FuncAnimation(fig, animate, frames=n_frames, interval=1000/fps, 
                        blit=False, repeat=True)
    
    # Save video
    print(f"Creating video with {n_frames} frames...")
    try:
        # Try FFmpeg first (better quality)
        writer = FFMpegWriter(fps=fps, bitrate=1800)
        anim.save(save_path, writer=writer)
        print(f"Video saved to {save_path}")
    except Exception as e:
        print(f"FFmpeg not available, trying Pillow (GIF)...")
        try:
            gif_path = save_path.replace('.mp4', '.gif')
            writer = PillowWriter(fps=fps)
            anim.save(gif_path, writer=writer)
            print(f"GIF saved to {gif_path}")
        except Exception as e2:
            print(f"Error saving video: {e2}")
            print("Make sure FFmpeg is installed: brew install ffmpeg")
    
    return anim, fig

